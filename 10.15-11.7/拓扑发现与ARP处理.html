<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>拓扑发现与ARP处理</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="ckxc" id="拓扑发现与arp处理">拓扑发现与ARP处理</h1><p data-anchor-id="3sxq"><code>sdn</code></p><div class="md-section-divider"></div><h2 data-anchor-id="lmnx" id="2019-10-24">2019-10-24</h2><div class="md-section-divider"></div><h1 data-anchor-id="bht7" id="basic-knowledge">basic knowledge</h1><p data-anchor-id="61dq">Openflow标准定义了控制器与交换机之间的交互协议，以及一组交换机操作。这个控制器—交换机协议运行在安全传输层协议(TLS)或无保护TCP连接之上。Openflow使用TCP端口6633或6653。</p><p data-anchor-id="zze9">每个流表中每个流条目包括三个部分：</p><p data-anchor-id="ecz3">(1)匹配match—使用ingressport，packetheader以及前一个flow table传递过来的metadata；</p><p data-anchor-id="e0eg">(2)计数counter---对匹配成功的包进行计数；</p><p data-anchor-id="vhkb">(3)操作instruction—修改actionset或者流水线处理</p><p data-anchor-id="ajtp">交换机针对SDN有一个比较重要的消息类型：Packet-In，主要针对未知数据流无法命中流表的时候，作上送控制器的操作。</p><p data-anchor-id="armz">同样，SDN控制器也有一个比较重要的消息类型：Packet-Out，主要针对下游SDN被管理设备，用于控制器指定从交换机的特定端口发送数据包，或者用于转发通过Packet-in消息接收到的数据包。Packet-Out报文中包含明确的Action动作。</p><div class="md-section-divider"></div><h1 data-anchor-id="vp1c" id="arp报文处理过程详解">ARP报文处理过程详解</h1><div class="md-section-divider"></div><h2 data-anchor-id="ktya" id="背景阐述">背景阐述：</h2><p data-anchor-id="u4bb">① 网络拓扑已发现</p><p data-anchor-id="i3hh">② 控制器采用ODL（OpenDayLight）</p><p data-anchor-id="5hck">③ 本地主机H1（10.0.0.1）和对端主机H2（10.0.0.2）均连接于SDN交换机下面</p><p data-anchor-id="zee2">④ 整个过程是H1请求H2的ARP，H2响应H1</p><div class="md-section-divider"></div><h2 data-anchor-id="t1lc" id="整个解析过程">整个解析过程</h2><p data-anchor-id="96qc">① H1去pingH2，即10.0.0.1去ping10.0.0.2。因为没有H2的MAC，此时需要做一次ARP解析。此时ARP请求（原本是广播）被SwitchA通过Openflow形式单播上送给Controller（packet-in报文）</p><p data-anchor-id="i9pk">② Controller收到H1的ARP请求，记录H1位于Switch A下游，且记录相关的位置信息。</p><p data-anchor-id="l7jy">③ 正因为Controller有所有交换机的拓扑及位置信息，此时Controller会给全网中每台SDN交换机都发送一个10.0.0.0/8网段的ARP请求消息，来请求10.0.0.2的MAC地址。但源IP并非10.0.0.1，而是Controller的网关地址，此处为10.0.0.254。此时报文均为packet-out，即通过Controller手工泛洪，但此泛洪是有选择性的，只针对同网段（10.0.0.0/8）</p><p data-anchor-id="98da">④ 所有交换机都能收到此ARP单播请求，而只有Switch B会做出回应，因为H2接在Switch B下游。此时通过packet-in，所有SDN交换机会将此ARP泛洪发送到同网段的端口。</p><p data-anchor-id="e69g">⑤ H2收到此时的ARP请求，正常做出回应。</p><p data-anchor-id="oiqv">⑥ Switch B收到H2的ARP响应，无脑上送到Controller。Controller收到ARP响应，发现正是前面发出的ARP请求的响应报文。记录此时的H2位置信息及ARP信息。</p><p data-anchor-id="hnfn">⑦ Controller通过Openflow将ARP响应回应给Switch A，Switch A将报文回送给H1。</p><p data-anchor-id="3vqr">此时做个小结，Controller已经完整知道SwitchA/SwitchB/H1/H2的位置信息及MAC/ARP信息。SwitchA/H1知道完整的ARP/MAC信息。而SwitchB也有H1/H2的完整IP。唯独H2此时只知道H1的IP，而不知道H1的MAC。</p><p data-anchor-id="p6lt">⑧ H1的整个ARP请求过程已经完成。接下来要输送ICMP请求报文。报文经由Switch A正常输送到H2（此时是实际转发流量，而且Switch A已有完整转发路径，不需要再上送Controller）</p><p data-anchor-id="hvol">⑨ H2收到ICMP报文，想要回应，但是没有H1的MAC，需要再次做ARP请求。此时H2请求H1的MAC地址，报文被Switch B上送Controller，Controller已有H1的MAC，则Controller做出回应，将H1的MAC回应给H2。</p><p data-anchor-id="n78u">⑩ H2收到ARP，则整个过程完整。回应ICMP报文。整个业务流打通。</p><p data-anchor-id="3bb6">可以看到，最关键的应该是第三步，即Controller发送伪装ARP报文给全局同网段交换机，以此来实现ARP广播的同样效果。但也正是这样一个看似合理的安全行为，带来了很多不安全的隐患。可以想象，Controller有几种方式可以获取终端主机的MAC情况：1.通过免费ARP的方式、2.定时申请下游终端的MAC方式，都可以保证对下游终端MAC的始终更新。</p><p data-anchor-id="p4sc">但同样，集中Controller的方式也带来了单点安全的风险考虑，一旦一台下游主机中毒，不断变化自己的MAC不断做出更新动作，此时会极大消耗Controller的资源，形成DOS攻击。同样，Controller的安全如果不是很坚固，则一旦被攻破，所有终端信息一览无余。</p><div class="md-section-divider"></div><h1 data-anchor-id="oev8" id="拓扑发现过程lldp">拓扑发现过程LLDP</h1><div class="md-section-divider"></div><h2 data-anchor-id="se6t" id="背景阐述-1">背景阐述：</h2><p data-anchor-id="uhc5">① 所有交换机彼此互联</p><p data-anchor-id="ll8v">② 交换机通过带外方式（或网管网方式）连接Controller</p><p data-anchor-id="cdc4">③ 交换机均使用Openflow协议。Openflow使用TCP端口6633或6653作为接收的监听端口。目前最新Openflow协议为1.5.1，详见ONF的spec。（<a href="https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/Openflow/Openflow-switch-v1.5.1.pdf" target="_blank">https://www.opennetworking.org/images/stories/downloads/sdn-resources/onf-specifications/Openflow/Openflow-switch-v1.5.1.pdf</a>）</p><p data-anchor-id="77w9">④ 无特殊Controller指定，各类型都OK</p><p data-anchor-id="a54a">那对于传统交换机而已，正常情况他们是通过LLDP等类似的邻居发现协议发现彼此网络设备，形成整网拓扑。而在SDN环境中，设备是无脑的，此时需要借助Openflow和LLDP同时工作，来保障Controller环境下能够对全网进行拓扑发现。</p><div class="md-section-divider"></div><h2 data-anchor-id="waf0" id="工作流程介绍">工作流程介绍：</h2><p data-anchor-id="ufkj">① 交换机连线至Controller，通过电信号，Controller发现有支持Openflow的SDN交换机接入，此时，Controller能够发现三台SDN交换机接入了。注意，此时三台设备之间的组网环境Controller是不清楚的。</p><p data-anchor-id="bjcp">② Controller通过packet-out报文，封装LLDP报文进Openflow，分别分发给每个交换机。此时的packet-out报文中含有动作：分发LLDP报文从交换机的每个端口发出去。</p><p data-anchor-id="wv9f">③ 此时交换机A根据Controller的动作指令，将LLDP报文从交换机所有接口发出去。交换机B和交换机C此时都能收到这个报文。</p><p data-anchor-id="o1xf">④ LLDP报文经过交换机之间的互联链路到达对端SDN交换机。而此时正因为交换机是SDN无脑交换机，他对于报文的处理都是上送Controller而非本地操作。则此时接受到LLDP的对端交换机会将LLDP报文再次封装，封装进packet-in，并上送至Controller。</p><p data-anchor-id="b9i6">⑤ 此时Controller收到对端SDN交换机封装的packet-in报文，报文里包含原本的LLDP报文。此时Controller就已经知道所有的拓扑连接关系了。</p><p data-anchor-id="jeju"><a href="http://d1net.com/virtual/news/357221.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank">引用自这里</a></p></div>
</body>
</html>