<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>DeDoS: Defusing DoS with Dispersion Oriented Software</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="ejqe" id="dedos-defusing-dos-with-dispersion-oriented-software">DeDoS: Defusing DoS with Dispersion Oriented Software</h1><p data-anchor-id="oip1"><code>security</code></p><div class="md-section-divider"></div><h2 data-anchor-id="maek" id="demoulin-h-m-vaidya-t-pedisich-i-et-al-dedos-defusing-dos-with-dispersion-oriented-softwarecproceedings-of-the-34th-annual-computer-security-applications-conference-acm-2018-712-722">Demoulin H M, Vaidya T, Pedisich I, et al. DeDoS: Defusing DoS with Dispersion Oriented Software[C]//Proceedings of the 34th Annual Computer Security Applications Conference. ACM, 2018: 712-722.</h2><p data-anchor-id="e2kn">本文提出的架构为DeDos，可以大量复制在攻击中被影响的组件，以精准添加资源从页抵御攻击。</p><div class="md-section-divider"></div><h1 data-anchor-id="ol7b" id="introduction">Introduction</h1><p data-anchor-id="xexy">对于网络攻击，当前商业解决方案为：使用更多的资源来处理，对于这种资源分配的办法解决Dos，本文提出了DeDos框架，将资源细粒度模块化分配，哪部分不足就复制出更多的资源给他。本文无法抵御所有可能的攻击，只能更好地管理资源，与应对特殊攻击的硬件相比较硬件更优秀，但本文的方法更具有普适性。 <br>
对于不耗网络带宽而耗主机资源的攻击，若过滤掉可疑FP和FN，若对整个网络服务进行复制又会浪费太多的资源，因此本文提出DeDoS，将数据中心的闲置资源拿来使用，并只复制被攻击的机器所缺少的资源。</p><div class="md-section-divider"></div><h1 data-anchor-id="rgf1" id="dedos设计">DeDoS设计</h1><p data-anchor-id="pt97"><img src="https://s2.ax1x.com/2019/10/21/Kl22PP.png" alt="Kl22PP.png" title=""> <br>
DeDoS应用是由许多的最小可分割单元组成(MSU)，如图1.每类MSU都负责一个特定的功能。每个DeDoS部署都有一个控制器提供API以及对MSU进行编排，同时对资源使用情况监控，当有MSU过载则创建新的MSU以进行均衡负载。</p><div class="md-section-divider"></div><h2 data-anchor-id="2c2s" id="msu">MSU</h2><p data-anchor-id="atqq">MSU应分多大，本文采用的是[31]中的依据。</p><div class="md-section-divider"></div><h2 data-anchor-id="2s51" id="inter-msu-communication">Inter-MSU communication</h2><p data-anchor-id="r80q">MSU可以暴露各自的API与其他MSU通信，由事件驱动。</p><div class="md-section-divider"></div><h2 data-anchor-id="m055" id="routing-tables">Routing tables</h2><p data-anchor-id="o84z">当XMSU相要激活YMSU功能，其不需要知晓Y的位置，因为这些都由控制器中的一个路由表维护。（<strong>这个路由表不是我们路由器那个</strong>）</p><div class="md-section-divider"></div><h2 data-anchor-id="bswo" id="dedos-runtime-api">DeDoS runtime API</h2><p data-anchor-id="zlya">每个机器都运行DeDoS并听控制器调度以添加或删除MSU，同时这些操作后控制器会相应更新路由表。</p><div class="md-section-divider"></div><h2 data-anchor-id="4j0p" id="对已有应用的支持">对已有应用的支持</h2><p data-anchor-id="hbze">需要重写少量的源码。</p><div class="md-section-divider"></div><h1 data-anchor-id="w7zi" id="资源分配">资源分配</h1><p data-anchor-id="gubq">每个机器管理自己的MSU，控制器提供全局需求视图。</p><div class="md-section-divider"></div><h2 data-anchor-id="vtpe" id="machine-local-scheduling">Machine-local scheduling</h2><p data-anchor-id="59bv">在不同MSU间转换依靠一些内核线程，这些线程每个都pinned to a particular core，DeDoS维护一个本地调度器，每个MSU有1个数据队列，当core空闲时其便根据策略选MSU，从其相应队列中找一个消息，传递消息并交给MSU处理。各个core之间不交互以提高效率。缺少使用轮询策略，每个线程可实现不同策略。</p><div class="md-section-divider"></div><h2 data-anchor-id="skd5" id="initial-msu-assignment">Initial MSU assignment</h2><p data-anchor-id="wppu">为一个应用初始化分配MSU时保证合格的吞吐量和延迟。</p><div class="md-section-divider"></div><h2 data-anchor-id="71j1" id="cloning-and-merging">Cloning and merging</h2><p data-anchor-id="2dje">决定是否创建一个新的MSU条件为消息队列长度是否大于0,是则说明任务超过了MSU的处理能力。控制器选一个host找最闲的核建MSU。若无闲host或最近创建过同样的MSU则创建会失败。 <br>
移除条件：1.消息队列长度为0；2.MSU资源消耗低于指定配置值。</p><div class="md-section-divider"></div><h1 data-anchor-id="gl85" id="implementation">Implementation</h1><p data-anchor-id="bytl"><a href="https://github.com/dedos-project/DeDOS" target="_blank">本文提供的源码</a></p><div class="md-section-divider"></div><h2 data-anchor-id="69qd" id="overview">Overview</h2><p data-anchor-id="diyr">架构图如图2 <br>
<img src="https://s2.ax1x.com/2019/10/21/K1AEUe.png" alt="K1AEUe.png" title=""> <br>
<strong>控制器</strong>：负载均衡并对DoS攻击进行回应。 <br>
<strong>Local runtime</strong>：本地运行的由本地的线程调度 <br>
<strong>Controller-runtime communication</strong>:控制器与每个运行实例通过一个long-live的TCP连接，并以此控制实例，实例也通过此报告统计信息。</p><div class="md-section-divider"></div><h2 data-anchor-id="mixo" id="dedos-local-runtime">DeDoS local runtime</h2><p data-anchor-id="n2n6"><strong>MSU</strong>:是由一些C函数构成。每个MSU都有一个数据队列，且MSU是在一个worker therads里运行，MSU可以输出信息到其他MSU的消息队列里。 <br>
<strong>Worker Threads</strong>:对MSU进行调度：1.从MSU池里选一个MSU；2.执行它；3.从它的数据对列里取数据度放入相应的MSU功能函数里，并重复3. <br>
将有阻塞操作的MSU分给non-pinned threads,无阻塞操作的MSU分给pinned threads. <br>
每个工作线程统计其MSU的资源使用和指标信息，线程队列用于控制消息，每个工作线程定期运行更新管理器以处理线程队列。 <br>
<strong>Local agents：</strong>本地代理通过long-lived TCP连接与控制器和其他DeDoS实例通信。如：接受控制消息并交给相应的工作线程；将工作线程收集的统计信息交给控制器。</p><p data-anchor-id="tm20"><strong>就总结到这里，后面是一些案例，这篇更像是一个使用手册。3w行代码。</strong></p></div>
</body>
</html>